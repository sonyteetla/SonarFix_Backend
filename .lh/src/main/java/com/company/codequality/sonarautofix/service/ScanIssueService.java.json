{
    "sourceFile": "src/main/java/com/company/codequality/sonarautofix/service/ScanIssueService.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1772176577738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1772176585528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -442,9 +442,9 @@\n throw new RuntimeException(\"Error fetching all issues\", e);\r\n }\r\n }\r\n \r\n-// Group by file (same structure )\r\n+// Group by file \r\n Map<String, List<Issue>> grouped =\r\n allIssues.stream()\r\n .collect(Collectors.groupingBy(Issue::getFilePath));\r\n \r\n"
                },
                {
                    "date": 1772176594560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -257,9 +257,8 @@\n                 parsedIssues.add(issue);\r\n             }\r\n         }\r\n \r\n-        // ðŸ”¥ IMPORTANT:\r\n         // Enrich AFTER parsing (adds description, fix info, examples, blocks, etc.)\r\n         ruleEngineService.enrichIssues(parsedIssues);\r\n \r\n         if (Boolean.TRUE.equals(autoFixOnly)) {\r\n"
                }
            ],
            "date": 1772176577738,
            "name": "Commit-0",
            "content": "package com.company.codequality.sonarautofix.service;\r\n\r\nimport com.company.codequality.sonarautofix.model.*;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.http.*;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.client.RestTemplate;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n@Service\r\npublic class ScanIssueService {\r\n\r\n    @Value(\"${sonar.host.url}\")\r\n    private String sonarUrl;\r\n\r\n    @Value(\"${sonar.token}\")\r\n    private String token;\r\n\r\n    private final RestTemplate restTemplate;\r\n    private final ObjectMapper objectMapper;\r\n    private final RuleEngineService ruleEngineService;\r\n\r\n    public ScanIssueService(RestTemplate restTemplate,\r\n                            ObjectMapper objectMapper,\r\n                            RuleEngineService ruleEngineService) {\r\n        this.restTemplate = restTemplate;\r\n        this.objectMapper = objectMapper;\r\n        this.ruleEngineService = ruleEngineService;\r\n    }\r\n\r\n    // ================= MAIN ENTRY =================\r\n\r\n    public IssueResponse fetchIssues(String projectKey,\r\n                                     List<String> softwareQualities,\r\n                                     List<String> severities,\r\n                                     List<String> rules,\r\n                                     Boolean autoFixOnly,\r\n                                     int page,\r\n                                     int pageSize) {\r\n\r\n        int safePageSize = Math.min(pageSize, 500);\r\n\r\n        String pagedUrl = buildSonarUrl(\r\n                projectKey,\r\n                softwareQualities,\r\n                severities,\r\n                rules,\r\n                page,\r\n                safePageSize\r\n        );\r\n\r\n        ResponseEntity<String> pagedResponse = callSonar(pagedUrl);\r\n\r\n        IssueResponse pagedResult =\r\n                processPagedResponse(pagedResponse.getBody(),\r\n                        autoFixOnly,\r\n                        page,\r\n                        safePageSize);\r\n\r\n        // --- FILTER COUNTS (kept exactly as your logic) ---\r\n\r\n        List<Issue> severityBase = fetchAllIssuesForCounts(\r\n                projectKey,\r\n                softwareQualities,\r\n                Collections.emptyList(),\r\n                rules,\r\n                autoFixOnly\r\n        );\r\n\r\n        List<Issue> qualityBase = fetchAllIssuesForCounts(\r\n                projectKey,\r\n                Collections.emptyList(),\r\n                severities,\r\n                rules,\r\n                autoFixOnly\r\n        );\r\n\r\n        List<Issue> ruleBase = fetchAllIssuesForCounts(\r\n                projectKey,\r\n                softwareQualities,\r\n                severities,\r\n                Collections.emptyList(),\r\n                autoFixOnly\r\n        );\r\n\r\n        Map<String, Long> severityCounts = severityBase.stream()\r\n                .collect(Collectors.groupingBy(\r\n                        Issue::getSeverity,\r\n                        Collectors.counting()));\r\n\r\n        Map<String, Long> qualityCounts = qualityBase.stream()\r\n                .collect(Collectors.groupingBy(\r\n                        Issue::getSoftwareQuality,\r\n                        Collectors.counting()));\r\n\r\n        Map<String, Long> ruleCounts = ruleBase.stream()\r\n                .collect(Collectors.groupingBy(\r\n                        Issue::getRule,\r\n                        Collectors.counting()));\r\n\r\n        FilterCounts filterCounts =\r\n                new FilterCounts(severityCounts, qualityCounts, ruleCounts);\r\n\r\n        return IssueResponse.builder()\r\n                .totalElements(pagedResult.getTotalElements())\r\n                .page(pagedResult.getPage())\r\n                .pageSize(pagedResult.getPageSize())\r\n                .totalPages(pagedResult.getTotalPages())\r\n                .content(pagedResult.getContent())\r\n                .filterCounts(filterCounts)\r\n                .build();\r\n    }\r\n\r\n    // ================= PAGED RESPONSE =================\r\n\r\n    private IssueResponse processPagedResponse(String body,\r\n                                               Boolean autoFixOnly,\r\n                                               int page,\r\n                                               int pageSize) {\r\n\r\n        try {\r\n\r\n            JsonNode root = objectMapper.readTree(body);\r\n            JsonNode issuesNode = root.path(\"issues\");\r\n\r\n            long total = root.path(\"paging\").path(\"total\").asLong();\r\n            int sonarPageSize = root.path(\"paging\").path(\"pageSize\").asInt();\r\n\r\n            List<Issue> parsedIssues =\r\n                    parseIssuesFromSonar(issuesNode, autoFixOnly);\r\n\r\n            Map<String, List<Issue>> grouped =\r\n                    parsedIssues.stream()\r\n                            .collect(Collectors.groupingBy(Issue::getFilePath));\r\n\r\n            List<FileIssueGroup> content =\r\n                    grouped.entrySet().stream()\r\n                            .map(e -> new FileIssueGroup(e.getKey(), e.getValue()))\r\n                            .collect(Collectors.toList());\r\n\r\n            int totalPages =\r\n                    (int) Math.ceil((double) total / sonarPageSize);\r\n\r\n            return IssueResponse.builder()\r\n                    .totalElements(total)\r\n                    .page(page)\r\n                    .pageSize(pageSize)\r\n                    .totalPages(totalPages)\r\n                    .content(content)\r\n                    .build();\r\n\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Failed parsing Sonar response\", e);\r\n        }\r\n    }\r\n\r\n    // ================= FETCH ALL FOR COUNTS =================\r\n\r\n    private List<Issue> fetchAllIssuesForCounts(String projectKey,\r\n                                                List<String> softwareQualities,\r\n                                                List<String> severities,\r\n                                                List<String> rules,\r\n                                                Boolean autoFixOnly) {\r\n\r\n        int page = 1;\r\n        int pageSize = 500;\r\n        boolean hasMore = true;\r\n\r\n        List<Issue> allIssues = new ArrayList<>();\r\n\r\n        while (hasMore) {\r\n\r\n            String url = buildSonarUrl(\r\n                    projectKey,\r\n                    softwareQualities,\r\n                    severities,\r\n                    rules,\r\n                    page,\r\n                    pageSize\r\n            );\r\n\r\n            ResponseEntity<String> response = callSonar(url);\r\n\r\n            JsonNode root;\r\n            try {\r\n                root = objectMapper.readTree(response.getBody());\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(\"Parsing error\", e);\r\n            }\r\n\r\n            JsonNode issuesNode = root.path(\"issues\");\r\n\r\n            List<Issue> pageIssues =\r\n                    parseIssuesFromSonar(issuesNode, autoFixOnly);\r\n\r\n            allIssues.addAll(pageIssues);\r\n\r\n            int total = root.path(\"paging\").path(\"total\").asInt();\r\n            hasMore = page * pageSize < total;\r\n            page++;\r\n        }\r\n\r\n        return allIssues;\r\n    }\r\n\r\n    // ================= SONAR CALL =================\r\n\r\n    private ResponseEntity<String> callSonar(String url) {\r\n\r\n        HttpHeaders headers = new HttpHeaders();\r\n        headers.setBasicAuth(token, \"\");\r\n\r\n        HttpEntity<Void> entity = new HttpEntity<>(headers);\r\n\r\n        ResponseEntity<String> response =\r\n                restTemplate.exchange(url, HttpMethod.GET, entity, String.class);\r\n\r\n        if (!response.getStatusCode().is2xxSuccessful()) {\r\n            throw new RuntimeException(\"SonarQube API returned error\");\r\n        }\r\n\r\n        return response;\r\n    }\r\n\r\n    // ================= ISSUE PARSER =================\r\n\r\n    private List<Issue> parseIssuesFromSonar(JsonNode issuesNode,\r\n                                             Boolean autoFixOnly) {\r\n\r\n        List<Issue> parsedIssues = new ArrayList<>();\r\n\r\n        if (issuesNode.isArray()) {\r\n            for (JsonNode node : issuesNode) {\r\n\r\n                String type = node.path(\"type\").asText();\r\n\r\n                String fullComponent = node.path(\"component\").asText();\r\n                String filePath = fullComponent.contains(\":\")\r\n                        ? fullComponent.substring(fullComponent.indexOf(\":\") + 1)\r\n                        : fullComponent;\r\n\r\n                Issue issue = Issue.builder()\r\n                        .key(node.path(\"key\").asText())\r\n                        .rule(node.path(\"rule\").asText())\r\n                        .severity(node.path(\"severity\").asText())\r\n                        .type(type)\r\n                        .softwareQuality(mapTypeToSoftwareQuality(type))\r\n                        .message(node.path(\"message\").asText())\r\n                        .filePath(filePath)\r\n                        .line(node.has(\"line\") ? node.get(\"line\").asInt() : null)\r\n                        .build();\r\n\r\n                parsedIssues.add(issue);\r\n            }\r\n        }\r\n\r\n        // ðŸ”¥ IMPORTANT:\r\n        // Enrich AFTER parsing (adds description, fix info, examples, blocks, etc.)\r\n        ruleEngineService.enrichIssues(parsedIssues);\r\n\r\n        if (Boolean.TRUE.equals(autoFixOnly)) {\r\n            parsedIssues = parsedIssues.stream()\r\n                    .filter(Issue::isAutoFixable)\r\n                    .collect(Collectors.toList());\r\n        }\r\n\r\n        return parsedIssues;\r\n    }\r\n\r\n    // ================= UTIL =================\r\n\r\n    private List<String> mapSoftwareQualityToTypes(List<String> qualities) {\r\n\r\n        List<String> types = new ArrayList<>();\r\n\r\n        for (String quality : qualities) {\r\n            switch (quality.toUpperCase()) {\r\n                case \"SECURITY\":\r\n                    types.add(\"VULNERABILITY\");\r\n                    break;\r\n                case \"RELIABILITY\":\r\n                    types.add(\"BUG\");\r\n                    break;\r\n                case \"MAINTAINABILITY\":\r\n                    types.add(\"CODE_SMELL\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return types;\r\n    }\r\n\r\n    private String mapTypeToSoftwareQuality(String type) {\r\n        switch (type) {\r\n            case \"BUG\": return \"Reliability\";\r\n            case \"VULNERABILITY\": return \"Security\";\r\n            case \"CODE_SMELL\": return \"Maintainability\";\r\n            default: return \"Unknown\";\r\n        }\r\n    }\r\n\r\n    private String buildSonarUrl(String projectKey,\r\n                                 List<String> softwareQualities,\r\n                                 List<String> severities,\r\n                                 List<String> rules,\r\n                                 int page,\r\n                                 int pageSize) {\r\n\r\n        StringBuilder url = new StringBuilder();\r\n\r\n        url.append(sonarUrl)\r\n                .append(\"/api/issues/search?\")\r\n                .append(\"componentKeys=\").append(projectKey)\r\n                .append(\"&resolved=false\")\r\n                .append(\"&p=\").append(page)\r\n                .append(\"&ps=\").append(pageSize);\r\n\r\n        if (severities != null && !severities.isEmpty()) {\r\n            url.append(\"&severities=\")\r\n                    .append(String.join(\",\", severities));\r\n        }\r\n\r\n        if (softwareQualities != null && !softwareQualities.isEmpty()) {\r\n\r\n            List<String> types = mapSoftwareQualityToTypes(softwareQualities);\r\n\r\n            if (!types.isEmpty()) {\r\n                url.append(\"&types=\")\r\n                        .append(String.join(\",\", types));\r\n            }\r\n        }\r\n\r\n        if (rules != null && !rules.isEmpty()) {\r\n            url.append(\"&rules=\")\r\n                    .append(String.join(\",\", rules));\r\n        }\r\n\r\n        return url.toString();\r\n    }\r\n\r\n    // ================= FETCH ALL (unchanged) =================\r\n\r\n    public List<Issue> fetchAllIssues(String projectKey,\r\n                                      List<String> softwareQualities,\r\n                                      List<String> severities,\r\n                                      List<String> rules) {\r\n\r\n        int page = 1;\r\n        int pageSize = 500;\r\n        boolean hasMore = true;\r\n\r\n        List<Issue> allIssues = new ArrayList<>();\r\n\r\n        while (hasMore) {\r\n\r\n            IssueResponse response =\r\n                    fetchIssues(projectKey,\r\n                            softwareQualities,\r\n                            severities,\r\n                            rules,\r\n                            false,\r\n                            page,\r\n                            pageSize);\r\n\r\n            response.getContent()\r\n                    .forEach(group -> allIssues.addAll(group.getIssues()));\r\n\r\n            hasMore = page < response.getTotalPages();\r\n            page++;\r\n        }\r\n\r\n        return allIssues;\r\n    }\r\n\r\n    // ================= DTO MAPPING =================\r\n\r\n    public List<MappedIssue> toMappedIssues(List<Issue> issues) {\r\n        if (issues == null)\r\n            return new ArrayList<>();\r\n\r\n        return issues.stream()\r\n                .map(this::toMappedIssue)\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    public MappedIssue toMappedIssue(Issue issue) {\r\n        return new MappedIssue(\r\n                issue.getRule(),\r\n                issue.getFilePath(),\r\n                issue.getLine() != null ? issue.getLine() : 0,\r\n                issue.getMessage(),\r\n                issue.getSeverity(),\r\n                issue.getSoftwareQuality(),\r\n                issue.isAutoFixable(),\r\n                issue.getFixType() != null ? issue.getFixType().name() : null\r\n        );\r\n    }\r\n    public IssueResponse fetchAllIssuesForViewer(String projectKey,\r\n            List<String> softwareQualities,\r\n            List<String> severities,\r\n            List<String> rules,\r\n            Boolean autoFixOnly) {\r\n\r\nint page = 1;\r\nint pageSize = 500;\r\nboolean hasMore = true;\r\n\r\nList<Issue> allIssues = new ArrayList<>();\r\n\r\nwhile (hasMore) {\r\n\r\nString url = buildSonarUrl(\r\nprojectKey,\r\nsoftwareQualities,\r\nseverities,\r\nrules,\r\npage,\r\npageSize\r\n);\r\n\r\nResponseEntity<String> response = callSonar(url);\r\n\r\ntry {\r\nJsonNode root = objectMapper.readTree(response.getBody());\r\n\r\nJsonNode issuesNode = root.path(\"issues\");\r\n\r\nList<Issue> pageIssues =\r\nparseIssuesFromSonar(issuesNode, autoFixOnly);\r\n\r\nallIssues.addAll(pageIssues);\r\n\r\nint total = root.path(\"paging\").path(\"total\").asInt();\r\nhasMore = page * pageSize < total;\r\npage++;\r\n\r\n} catch (Exception e) {\r\nthrow new RuntimeException(\"Error fetching all issues\", e);\r\n}\r\n}\r\n\r\n// Group by file (same structure as paged)\r\nMap<String, List<Issue>> grouped =\r\nallIssues.stream()\r\n.collect(Collectors.groupingBy(Issue::getFilePath));\r\n\r\nList<FileIssueGroup> content =\r\ngrouped.entrySet().stream()\r\n.map(e -> new FileIssueGroup(e.getKey(), e.getValue()))\r\n.collect(Collectors.toList());\r\n\r\nreturn IssueResponse.builder()\r\n.totalElements(allIssues.size())\r\n.page(1)\r\n.pageSize(allIssues.size())\r\n.totalPages(1)\r\n.content(content)\r\n.filterCounts(null) \r\n.build();\r\n}\r\n}\r\n"
        }
    ]
}