{
    "sourceFile": "src/main/java/com/company/codequality/sonarautofix/service/AutoFixEngine.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1772176458501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1772176458501,
            "name": "Commit-0",
            "content": "package com.company.codequality.sonarautofix.service;\r\n\r\nimport com.company.codequality.sonarautofix.model.*;\r\nimport com.company.codequality.sonarautofix.repository.FixRecordRepository;\r\nimport com.company.codequality.sonarautofix.strategy.FixStrategy;\r\nimport com.github.javaparser.StaticJavaParser;\r\nimport com.github.javaparser.ast.CompilationUnit;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.util.*;\r\n\r\n@Service\r\npublic class AutoFixEngine {\r\n\r\n    private final Map<FixType, FixStrategy> strategyMap = new HashMap<>();\r\n    private final ScanService scanService;\r\n    private final FixRecordRepository fixRecordRepository;\r\n\r\n    public AutoFixEngine(List<FixStrategy> strategies,\r\n                         @Lazy ScanService scanService,\r\n                         FixRecordRepository fixRecordRepository) {\r\n\r\n        for (FixStrategy strategy : strategies) {\r\n            strategyMap.put(strategy.getFixType(), strategy);\r\n        }\r\n\r\n        this.scanService = scanService;\r\n        this.fixRecordRepository = fixRecordRepository;\r\n    }\r\n\r\n    public int applyFixes(List<FixRequest> requests,\r\n                          String projectPath,\r\n                          String projectKey,\r\n                          String scanId) {\r\n\r\n        if (requests == null || requests.isEmpty()) {\r\n            throw new IllegalArgumentException(\"No fixes provided\");\r\n        }\r\n\r\n        int totalFixed = 0;\r\n        Map<FixType, Integer> fixReport = new HashMap<>();\r\n\r\n        ScanTask task = null;\r\n        if (scanId != null && !scanId.isBlank()) {\r\n            task = scanService.getScanTask(scanId);\r\n        }\r\n\r\n        try {\r\n\r\n            // Group fixes by file\r\n            Map<String, List<FixRequest>> grouped = new HashMap<>();\r\n\r\n            for (FixRequest request : requests) {\r\n\r\n                if (request.getFilePath() == null ||\r\n                        request.getFilePath().isBlank() ||\r\n                        request.getLine() <= 0) {\r\n                    continue;\r\n                }\r\n\r\n                grouped.computeIfAbsent(request.getFilePath(),\r\n                        k -> new ArrayList<>()).add(request);\r\n            }\r\n\r\n            for (Map.Entry<String, List<FixRequest>> entry : grouped.entrySet()) {\r\n\r\n                String filePath = entry.getKey();\r\n                List<FixRequest> fileFixes = entry.getValue();\r\n\r\n                // Sort bottom → top to avoid line shift issues\r\n                fileFixes.sort((a, b) ->\r\n                        Integer.compare(b.getLine(), a.getLine()));\r\n\r\n                Path path = Path.of(projectPath, filePath);\r\n\r\n                if (!Files.exists(path)) {\r\n                    System.out.println(\"⚠ File not found: \" + path);\r\n                    continue;\r\n                }\r\n\r\n                CompilationUnit cu;\r\n                try {\r\n                    cu = StaticJavaParser.parse(path);\r\n                } catch (Exception e) {\r\n                    System.out.println(\"⚠ Failed to parse file: \" + path);\r\n                    continue;\r\n                }\r\n\r\n                for (FixRequest request : fileFixes) {\r\n\r\n                    FixType type;\r\n                    try {\r\n                        type = FixType.valueOf(request.getFixType());\r\n                    } catch (Exception e) {\r\n                        System.out.println(\"⚠ Invalid FixType: \" + request.getFixType());\r\n                        continue;\r\n                    }\r\n\r\n                    FixStrategy strategy = strategyMap.get(type);\r\n                    if (strategy == null) {\r\n                        System.out.println(\"⚠ No strategy for: \" + type);\r\n                        continue;\r\n                    }\r\n\r\n                    try {\r\n\r\n                        boolean applied =\r\n                                strategy.apply(cu, request.getLine());\r\n\r\n                        if (applied) {\r\n\r\n                            totalFixed++;\r\n                            fixReport.put(type,\r\n                                    fixReport.getOrDefault(type, 0) + 1);\r\n\r\n                            FixRecord record = FixRecord.builder()\r\n                                    .projectKey(projectKey)\r\n                                    .filePath(filePath)\r\n                                    .line(request.getLine())\r\n                                    .fixType(type.name())\r\n                                    .fixedAt(java.time.LocalDateTime.now())\r\n                                    .build();\r\n\r\n                            fixRecordRepository.save(record);\r\n\r\n                        } else {\r\n                            System.out.println(\"⚠ Fix not applied at line \"\r\n                                    + request.getLine());\r\n                        }\r\n\r\n                    } catch (Exception ex) {\r\n\r\n                        System.out.println(\"⚠ Fix failed at line \"\r\n                                + request.getLine() + \" in \" + filePath);\r\n\r\n                        if (task != null) {\r\n                            task.addSuggestion(\r\n                                    new FixSuggestion(\r\n                                            filePath,\r\n                                            request.getLine(),\r\n                                            type.name(),\r\n                                            \"Manual fix required. AutoFix skipped to prevent compile error.\",\r\n                                            \"Review rule: \" + type.name()\r\n                                    )\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Write modified file\r\n                try {\r\n                    Files.write(path,\r\n                            cu.toString().getBytes(StandardCharsets.UTF_8));\r\n                } catch (Exception e) {\r\n                    System.out.println(\"⚠ Failed to write file: \" + path);\r\n                }\r\n            }\r\n\r\n            // Store execution report before re-scan\r\n            if (task != null) {\r\n\r\n                Map<String, Integer> reportForUi = new HashMap<>();\r\n\r\n                for (Map.Entry<FixType, Integer> entry : fixReport.entrySet()) {\r\n                    reportForUi.put(entry.getKey().name(), entry.getValue());\r\n                }\r\n\r\n                task.setFixExecutionReport(reportForUi);\r\n                task.setTotalFixesApplied(totalFixed);\r\n            }\r\n\r\n            // Re-scan\r\n            try {\r\n            \tif (scanId == null || scanId.isBlank()) {\r\n            \t    throw new IllegalStateException(\"scanId required for re-scan\");\r\n            \t}\r\n\r\n            \tscanService.reScan(projectPath, projectKey, scanId);\r\n            \t\r\n            } catch (Exception e) {\r\n                System.out.println(\"⚠ Re-scan failed (non-critical): \" + e.getMessage());\r\n            }\r\n\r\n            System.out.println(\"\\n====== AutoFix Execution Report ======\");\r\n            fixReport.forEach((k, v) ->\r\n                    System.out.println(k + \" -> \" + v + \" fixes\"));\r\n            System.out.println(\"Total fixes applied: \" + totalFixed);\r\n            System.out.println(\"======================================\\n\");\r\n\r\n            return totalFixed;\r\n\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Auto fix failed\", e);\r\n        }\r\n    }\r\n}\r\n"
        }
    ]
}